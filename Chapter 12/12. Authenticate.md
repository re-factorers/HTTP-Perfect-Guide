# Authenticate

## 인증

* 인증은 당신이 누구인지 증명하는 것이다.
* 웹 애플리케이션이 HTTP 요청을 받으면, 서버는 요청을 처리하는 대신에 현재 사용자가 누우인지를 알 수 있게 비밀번호 같이 개인 정보를 요구하는 `인증요구`로 응땁할 수 있다.
* 사용자가 다시 요청을 보낼 때는 인증정보를 첨부해야한다. 만약 인증정보가 맞지 않으면 서버는 다시 인증요구를 보내거나 에러를 낼 수 있다.

### 인증 프로토콜과 헤더

* HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.
* HTTP에는 기본 인증과 다이제스트 인증이라는 두 가지 공식적인 인증 프로토콜이 있다.

|단계|헤더|설명|메서드/상태|
|:-----:|:---------:|:---:|:---:|
|요청| - |첫 번째 요청에는 인증 정보가 없다.|GET|
|인증요구|WWW-Authenticate|서버는 사용자에게 사용자 이름과 비밀번호를 제공하라는 지시의 의미로 401 상태 정보와 함께 요청을 반려한다. 서버에는 각각 다른 비밀번호가 있는 영역들이 있을 것이므로, 서버는 WWW-Authenticate 헤더에 해당 영역을 설명해 놓는다.|401 Unauthorized|
|인증|Authorization|클라이언트는 요청을 다시 보내는데, 이번에는 인증 알고리즘과 사용자 이름과 비밀번호를 기술한 Authorization 헤더를 함께 보낸다.|GET|
|성공|Authentication-Info|인증정보가 정확하면, 서버는 문서와 함께 응답한따. 어떤 인증 알고리즘은 선택적인 헤더인 Authentication-Info에 인증 세션에 관한 추가 정보를 기술해서 응답하기도 한다.|200 OK|

![12-2](./img/12-2.png)

### 보안영역

* HTTP가 어떻게 각 리소스마다 다른 접근 조건을 다루는지 알아본다.
* 그림 12-2b에서 서버가 클라이언트로 인증요구를 할 때, realm 지시자가 기술되어 있는 WWW-Authenticate 헤더를 봤을 것이다.
* 웹 서버는 기밀문서를 보안 영역(realm) 그룹으로 나눈다. 보안 영역은 저마다 다른 사용자 권한을 요구한다.

```
HTTP/1.0 401 Unauthorized
WWW-Authenticate: Basic realm="Family"

HTTP/1.0 401 Unauthorized
WWW-Authenticate: Basic realm="Corporate Financials"
```

![12-3](./img/12-3.png)

### 기본 인증

* 기본인증은 원래 HTTP/1.0에 기술되어 있었지만, HTTP인증 상세 내용을 다루는 RFC 2617로 옮겨졌다.
* 서버는 200 대신 401 상태 코드와 함께 클라이언트가 접근하려고 했던 보안 영역을 WWW-Authenticate에 기술해서 응답하여 인증요구를 시작한다.

> 인증요구(서버 -> 클라이언트) : 각 사이트는 보안 영역마다 다른 비밀번호가 있을 것이다. realm은 요청 받은 문서 집합의 이름을 따옴표로 가싼 것으로, 사용자는 이 정보를 보고 어떤 비밀번호를 사용해야 하는지 알 수 있다. (`WWW-Authenticate: Basic realm=따옴표로 감싼 문서 집합 정보`)

> 응답(클라이언트 -> 서버) : 사용자 이름과 비밀번호는 콜론으로 잇고, base-64 인코딩을 해서 사용자 이름과 비밀번호에 쉽게 국제문자를 포함할 수 있게하고, 네트워크 트래픽에 사용자 이름과 비밀번호가 노출되지 않게 한다. (`Authorization: Basic base-64로 인코딩한 사용자의 이름과 비밀번호`)

* 사용자 이름 : brain-totty
* 비밀번호 : Ow!
* Befor base64 encoding : brain-totty:Ow!
* Base64 : YnJhaW4tdG90dHk6T3ch
* Request Header : Authorization: Basic YnJhaW4tdG90dHk6T3ch

### 프락시 인증

|웹 서버|프락시 서버|
|:-----:|:-----:|
|비인증 상태코드 : 401|비인증 상태코드: 407|
|WWW-Authenticate|Proxy-Authenticate|
|Authorization|Proxy-Authentication|
|Authentication-Info|Proxy-Authentication-Info|

## 기본인증의 보안 결함

* 기본인증은 단순하고 편리하지만 안심할 수는 없다. 기본인증은 악의적이지 않은 누군가가 의도치 않게 리소스에 접근하는 것을 막는데 사용하거나, SSL 같은 암호 기술과 혼용한다.

### 보안결함 예제

* 기봉인증은 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송한다.
* base64 인코딩은 우호적인 관계사가 네트워크를 관찰하면서 본의아니게 비밀번호를 알게되는 일이 발생하지 않도록 인코딩 하는 것이다.
* 하지만 쉽게 디코딩할 수 있다는 문제가 있다.
* base64 인코딩된 비밀번호를 보내는 것은 비밀번호 그대로 보내는 것 과 사실상 같다.
* 나쁜 의도를 가진 외부 사업자가 기본 인증으로 보낸 사용자의 이름과 비밀번호를 가로채는 경우를 막기위해서 모든 HTTP 트랜젝션을 SSL 암호화 채널을 통해서 보내거나 보안이 더우 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좋다.

* 좀 더 복잡한 방식의 인코딩을 사용한다고해도 제 3자가 이를 가로채서 원 서버에 보내어 인증에 성공하고 서버에 접근할 수 있다. 기본 인증은 이러한 재전송 공격을 예방하기 위한 어떤 일도 하지 않는다.

* 기본인증은 가짜 서버의 위장에 취약하다. 만약 사용자가 가짜 서버나 가짜 게이트에 연결되어 있는데도, 사용자는 기본 인증을 수행하는 검증된 서버에 연결되어 있다고 믿고 있다면, 공격자는 사용자에게 비밀번호를 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 것이다.

> 종합해보면 기본인증은 일반적인 환경에서 개인화나 접근을 제어하는데 편리하며, 다른 사람들이 보지 않기를 원하기는 하지만 보더라도 치명적이지 않은 경우에는 여전히 유용하다.
> 기본인증은 사용자 이름과 비밀번호를 악의적인 개인들에게 숨기려고 암호화된 데이터 전송(SSL 같은)과 함께 연계해서 사용할 수 있다.