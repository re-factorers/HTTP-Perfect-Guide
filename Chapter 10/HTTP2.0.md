# HTTP/2.0

 - HTTP 2.0이라고도 불리는 HTTP/2는 Hypertext Transfer Protocol Version 2의 약자로서, 2015년 IETF에 의해 공식적으로 발표된 HTTP/1.1(기존 표준)의 차기 버전이다.

## 등장배경
 - HTTP/1.1의 메시지 포멧은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다.(성능적으로 취약한 부분 존재)
 - HTTP의 메시지 교환방식은 단순함 면에서는 더할 나위 없었지만, 응답을 받아야만 그 다음 요청을 보낼 수 있기 때문에 심각한 지연을 피할 수 없었다.
 - 이 문제를 해결하기위해 병렬 커넥션이나 파이크라인 커넥션이 도입되었지만 근본적인 해결은 되지 못했다.

## 개요
 - HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다.
 - HTTP/2.0 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담긴다(HTTP 헤더는 압축되어 담긴다.)
 - 프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다. 한 개의 스트림이 한 쌍의 요청과 응답을 처리한다.
 - 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로 여러 개의 요청과 응답을 동시에 처리하는 것이 가능.
 - 스트림에 대한 흐름제어와 우선순위 부여기능 제공
 - 서버 푸시기능의 도입으로 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 그에 대한 요청을 명시적으로 받지 않더라도 능동적으로 클라이언트에게 보내줄 수 있다.

## HTTP/1.1과의 차이점
 - 기존에 Plain Text(평문)를 사용하고, 개행으로 구별되면 HTTP/1.x 프로토콜과 달리, 2.0에서는 바이너리 포멧으로 인코딩 된 Message, Frame으로 구성된다.
 - HTTP 1.x의 HOL(Head-of-Line) Blocking 문제(컴퓨터 네트워킹에서 패킷 대기열이 존재 할 때, 앞선(Head) 패킷이 지연될 때 발생하는 성능 저하 현상) 해결

### 프레임
 - HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다. (8Byte Header + 최대 16,383 Byte Payload)

### 스트림과 멀티플렉싱
 - 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
 - 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다.
 - 클라이언트는 새 스트림을 만들어 그를 통해 HTTP 요청을 보낸다. 요청을 받는 서버는 그 요청과 같은 스트림으로 응답을 보낸다. 그러고나면 스트림은 닫히게 된다.

> HTTP/1.1에서는 한 TCP 커넥션을 통해 요청을 보냈을 때, 그에 대한 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있다. 따라서 웹브라우저들은 회전 지연을 줄이기 위해 여러 개의 TCP 커넥션을 만들어 동시에 여러 개의 요청을 보내는 방법을 사용한다.
> 그러나 TCP 커넥션을 무한정 만들 수는 없기 때문에 한 페이지에 보내야 할 요청이 수십에서 수백에 달하는 오늘날에는 회전 지연이 늘어나는 것을 피하기 어렵다.

 - 그러나 HTTP/2.0에서는 하느의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다. 따라서 하나의 HTTP/2.0 커넥션을 통해 여러 개의 요청이 동시에 보내질 수 있기 때문에 이 문제는 쉽게 해결될 수 있다.

### 헤더압축
 - HTTP/1.1에서 헤더는 아무런 압축 없이 그대로 전송되었다. 요즘에는 웹페이지 하나를 보기 위해 수십에서 수백 번의 요청을 보내기 때문에 헤더의 크기가 회전지연과 대역폭 양쪽 모두에 실질적인 영향을 끼치게 되었다.
 - HTTP/2.0에서는 HTTP 메시지의 헤더를 압축해서 전송한다.(HPACK 명세 사용)
    - 하나의 커넥션에서 미리 전달되었던 요청과 중복된 Header를 다음 요청에는 포함하지 않는다.

### 서버푸시
 - HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.
 - 이 기능은 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다.
    - HTML문서를 요청 받은 서버는 그 HTML 문서가 링크하고 있는 이미지, CSS 파일, JS파일 등의 리소스를 클라이언트에게 푸시할 수 있을 것이다.(회전지연 감소)
 - 리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 `PUSH_PROMISE` 프레임을 보내어 미리 알려주어야 한다.(서버가 푸시 하려고하는 지원을 클라이언트가 별도로 또 요청하게 되는 상황을 피하기 위함)

## 알려진 보안이슈
 - 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)
 - 긴 커넥션 유지로 인한 개인정보 누출 우려